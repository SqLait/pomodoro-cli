#!/bin/bash

# File for storing sessions
DATA_FILE="$HOME/Documents/.pomodoro_sessions"
CONFIG_PATH="$HOME/.config/pomo"
CONFIG_FILE="$HOME/.config/pomo/config.txt"
# Colors
GREEN="\e[32m"
RED="\e[31m"
BLUE="\e[34m"
BLACK="\e[30m"
YELLOW="\e[33m"
MAGENTA="\e[35m"
CYAN="\e[36m"
LIGHT_GRAY="\e[37m"
GRAY="\e[90m"
LIGHT_RED="\e[91m"
LIGHT_GREEN="\e[92m"
LIGHT_YELLOW="\e[93m"
LIGHT_BLUE="\e[94m"
LIGHT_MAGENTA="\e[95m"
LIGHT_CYAN="\e[96m"

# Special colors
RESET="\e[0m"
BOLD="\e[1m"
FAINT="\e[2m"
ITALIC="\e[3m"
UNDERLINED="\e[4m"

# Parse arguments
TAG=""
POMODORO_DURATION=25
BREAK_DURATION=5
NUM_POM=4
MODE="run"
SHOW_SESSION=""
SHOW_LIST=false
RECONNECT=false
REMOVE=false
SOUND_FILE=""
NO_SAVE=false
MIN_OR_SEC=60
MIN_OR_SEC_BREAK=60

BORDER_COLOR=""
BORDER_PAUSE_COLOR=""
BORDER_COMPLETE_COLOR=""
TEXT_COLOR=""
TAG_COLOR=""

create_config_file() {
    if [ ! -d "$HOME/.config/pomo" ]; then
        mkdir -p $HOME/.config/pomo
        touch $HOME/.config/pomo/config.txt
    fi
}

# Function to save the current session status
save_session() {
    if [ -z "$TAG" ]; then return; fi
    # Remove existing entry for this tag
    if [ -f "$DATA_FILE" ]; then
        grep -v "^$TAG:" "$DATA_FILE" > /tmp/pomodoro_tmp
        mv /tmp/pomodoro_tmp "$DATA_FILE"
    fi
    # Append new status
    echo -n "$TAG:" >> "$DATA_FILE"
    for ((i=0; i<NUM_POM; i++)); do
        if [ $i -gt 0 ]; then echo -n "," >> "$DATA_FILE"; fi
        echo -n "${STATUS[$i]}" >> "$DATA_FILE"
    done
    echo "" >> "$DATA_FILE"
}

# Function to load session status
load_session() {
    if [ ! -f "$DATA_FILE" ]; then
        echo "No session found for \"$TAG\""
        exit 1
    fi
    LINE=$(grep "^$TAG:" "$DATA_FILE")
    if [ -z "$LINE" ]; then
        echo "No session found for \"$TAG\""
        exit 1
    fi
    VALS=${LINE#*:}
    IFS=',' read -ra ARR <<< "$VALS"
    for ((i=0; i<${#ARR[@]} && i<NUM_POM; i++)); do
        STATUS[$i]=${ARR[$i]}
    done
    # Find the first incomplete pomodoro
    for ((i=0; i<NUM_POM; i++)); do
        if [ ${STATUS[$i]} -eq 0 ]; then
            CURRENT=$i
            break
        fi
    done
}

# Function to remove session
remove_session() {
    if [ -z "$TAG" ]; then
        echo "Error: tag is required for -rm/--remove"
        exit 1
    fi
    if [ -f "$DATA_FILE" ]; then
        grep -v "^$TAG:" "$DATA_FILE" > /tmp/pomodoro_tmp
        mv /tmp/pomodoro_tmp "$DATA_FILE"
        echo "Session \"$TAG\" removed"
    else
        echo "No session found for \"$TAG\""
    fi
    exit 0
}

resolve_config_color() {
    local color_name="$1"
    local fallback_color="$2"
    case "${color_name,,}" in
        black) echo -e "$BLACK" ;;
        red) echo -e "$RED" ;;
        green) echo -e "$GREEN" ;;
        yellow) echo -e "$YELLOW" ;;
        blue) echo -e "$BLUE" ;;
        magenta) echo -e "$MAGENTA" ;;
        cyan) echo -e "$CYAN" ;;
        light_gray) echo -e "$LIGHT_GRAY" ;;
        gray) echo -e "$GRAY" ;;
        light_red) echo -e "$LIGHT_RED" ;;
        light_green) echo -e "$LIGHT_GREEN" ;;
        light_yellow) echo -e "$LIGHT_YELLOW" ;;
        light_blue) echo -e "$LIGHT_BLUE" ;;
        light_magenta) echo -e "$LIGHT_MAGENTA" ;;
        light_cyan) echo -e "$LIGHT_CYAN" ;;
        white | none ) echo -e "\e[0m" ;; # No Color
        * | "") echo -e "$fallback_color" ;; # Fallback
    esac
}

load_config() {
    if [ ! -d "$HOME/.config/pomo" ]; then
        return
    fi

    local border_color=$(grep "^border_color" "$CONFIG_FILE" | awk '{print $NF}')
    local border_pause_color=$(grep "^border_pause_color" "$CONFIG_FILE" | awk '{print $NF}')
    local border_complete_color=$(grep "^border_complete_color" "$CONFIG_FILE" | awk '{print $NF}')
    local text_color=$(grep "^text_color" "$CONFIG_FILE" | awk '{print $NF}')
    local tag_color=$(grep "^tag_color" "$CONFIG_FILE" | awk '{print $NF}')

    BORDER_COLOR=$(resolve_config_color "$border_color" $GREEN)
    BORDER_PAUSE_COLOR=$(resolve_config_color "$border_pause_color" $RED)
    BORDER_COMPLETE_COLOR=$(resolve_config_color "$border_complete_color" $RED)
    TEXT_COLOR=$(resolve_config_color "$text_color" $RESET)
    TAG_COLOR=$(resolve_config_color "$tag_color" $BLUE)
}

load_config
# Trap for Ctrl+C to save
trap 'save_session; exit' INT TERM

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            echo ""
            echo "pomo: a lightweight pomodoro timer in your terminal."
            echo "USAGE: pomo [TAG].. [OPTIONS].."
            echo "─────────────────────────────────────────────────────────"
            echo "-t, --tag             |   Tag name for the current session."
            echo "-s, --session         |   Shows progress of provided session."
            echo "-l, --list            |   lists all known sessions."
            echo "-d, --duration        |   Change the default duration (25 minutes) to a custom value (in minutes)"
            echo "-p, --pomodoros       |   Change the default value (4) of the amount of times you want to repeat the timer."
            echo "-r, --reconnect       |   Reconnect to a stopped session."
            echo "-rm, --remove         |   Remove a session from the database."
            echo "-a, --alarm           |   Audio file that will when the time has passed."
            echo "-cc, --create-config  |   Creates a config file at $HOME/.config/pomo."
            echo "─────────────────────────────────────────────────────────"
            echo "USAGE: pomo [TAG].. [SETTINGS].."
            echo "─────────────────────────────────────────────────────────"
            echo "-ns, --no-save     |   Will not save the initialised session."
            exit
            ;;
        -t|--tag)
            TAG="${2//\"}" # Remove quotes from tag
            shift 2
            ;;
        -s|--session)
            SHOW_SESSION="${2//\"}" # Remove quotes from session tag
            MODE="display"
            shift 2
            ;;
        -l|--list)
            SHOW_LIST=true
            MODE="list"
            shift
            ;;
        -d|--duration)
            case "$2" in
                *s)
                    MIN_OR_SEC=1
                    POMODORO_DURATION="${2%s}"
                    ;;
                *m)
                    MIN_OR_SEC=60
                    POMODORO_DURATION="${2%m}"
                    ;;
                *)
                    MIN_OR_SEC=60
                    POMODORO_DURATION="$2"
                    ;;
            esac
            shift 2
            ;;
        -b|--break)
            case "$2" in
                *s)
                    MIN_OR_SEC_BREAK=1
                    BREAK_DURATION="${2%s}"
                    ;;
                *m)
                    MIN_OR_SEC_BREAK=60
                    BREAK_DURATION="${2%m}"
                    ;;
                *)
                    MIN_OR_SEC_BREAK=60
                    BREAK_DURATION="$2"
                    ;;
            esac
            shift 2
            ;;
        -p|--pomodoros)
            NUM_POM="$2"
            shift 2
            ;;
        -r|--reconnect)
            RECONNECT=true
            TAG="${2//\"}" # Remove quotes from tag
            shift 2
            ;;
        -rm|--remove)
            REMOVE=true
            TAG="${2//\"}" # Remove quotes from tag
            shift 2
            ;;
        -ns|--no-save)
            NO_SAVE=true
            shift
            ;;
        -cc|--create-config)
            create_config_file
            echo "Config created at $CONFIG_PATH"
            shift
            exit 0
            ;;
        -a|--alarm)
            SOUND_FILE="${2//\"}"
            shift 2
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# Handle remove mode
if [ "$REMOVE" = true ]; then
    remove_session
fi

# Handle display mode
if [ "$MODE" = "display" ]; then
    if [ -z "$SHOW_SESSION" ]; then
        echo "Error: tag is required for -s/--session"
        exit 1
    fi
    if [ ! -f "$DATA_FILE" ]; then
        echo "No session found for \"$SHOW_SESSION\""
        exit 0
    fi
    LINE=$(grep "^$SHOW_SESSION:" "$DATA_FILE")
    if [ -z "$LINE" ]; then
        echo "No session found for \"$SHOW_SESSION\""
        exit 0
    fi
    VALS=${LINE#*:}
    echo -n -e "${BLUE}\"$SHOW_SESSION\"${RESET}: ["
    FIRST=1
    IFS=',' read -ra ARR <<< "$VALS"
    for V in "${ARR[@]}"; do
        if [ $FIRST -eq 0 ]; then echo -n ", "; fi
        if [ "$V" = "1" ]; then
            echo -n -e "${GREEN}X${RESET}"
        else
            echo -n -e "${RED}X${RESET}"
        fi
        FIRST=0
    done
    echo "]"
    exit 0
fi

# Handle list mode
if [ "$SHOW_LIST" = true ]; then
    if [ ! -f "$DATA_FILE" ]; then
        echo "No pomodoro sessions found."
        exit 0
    fi
    while IFS= read -r LINE; do
        if [ -z "$LINE" ]; then continue; fi
        STAG=${LINE%%:*}
        VALS=${LINE#*:}
        echo -n -e "${BLUE}\"$STAG\"${RESET}: ["
        FIRST=1
        IFS=',' read -ra ARR <<< "$VALS"
        for V in "${ARR[@]}"; do
            if [ $FIRST -eq 0 ]; then echo -n ", "; fi
            if [ "$V" = "1" ]; then
                echo -n -e "${GREEN}X${RESET}"
            else
                echo -n -e "${RED}X${RESET}"
            fi
            FIRST=0
        done
        echo "]"
    done < "$DATA_FILE"
    exit 0
fi

# Run mode
if [ -z "$TAG" ]; then
    echo "Error: tag is required to run a session."
    exit 1
fi

# Initialize status array
declare -a STATUS
for ((i=0; i<NUM_POM; i++)); do
    STATUS[$i]=0
done
CURRENT=0

# Load existing session if reconnecting
if [ "$RECONNECT" = true ]; then
    load_session
fi

# Run the pomodoros
for ((; CURRENT < NUM_POM; CURRENT++)); do
    # Skip completed pomodoros
    if [ ${STATUS[$CURRENT]} -eq 1 ]; then
        continue
    fi
    TIME_LEFT=$((POMODORO_DURATION * MIN_OR_SEC))
    TIME_LEFT_PAUSE=$((BREAK_DURATION * MIN_OR_SEC_BREAK))
    PAUSED=0
    COMPLETED=0
    TAG_WIDTH=20
    MSG_WIDTH=48
    TIMER_STATE="RUNNING"

    while [ $TIME_LEFT -gt 0 ] || [ $PAUSED -eq 1 ]; do
        # Clear screen
        printf "\e[2J\e[H"

        if [ $PAUSED -eq 1 ]; then
            #BORDER_COLOR=$RED
            MSG="Paused"
            TIMER_STATE="PAUSED ─"
        else
            #BORDER_COLOR=$GREEN
            MSG=""
            TIMER_STATE="RUNNING "
        fi

        # Truncate tag if too long
        if (( ${#TAG} > TAG_WIDTH )); then
            TAG="${TAG:0:$((TAG_WIDTH - 3))}..."  # Add ellipsis if needed
        fi

        # Calculate tag padding
        TAG_PADDING=$(( TAG_WIDTH - ${#TAG} ))
        (( TAG_PADDING < 0 )) && TAG_PADDING=0

        # Truncate message if too long
        if (( ${#MSG} > MSG_WIDTH )); then
            MSG="${MSG:0:$((MSG_WIDTH - 3))}..."  # Add ellipsis if needed
        fi

        # Calculate message padding
        MSG_PADDING=$(( MSG_WIDTH - ${#MSG} ))
        (( MSG_PADDING < 0 )) && MSG_PADDING=0

        # Time formatting
        MINS=$(printf "%02d" $((TIME_LEFT / 60)))
        SECS=$(printf "%02d" $((TIME_LEFT % 60)))


        if [ "$MSG" = "" ]; then
            echo -e "${BORDER_COLOR}┌──── Pomodoro - ${TIMER_STATE}─────────────────────────┐${RESET}"
            echo -e "${BORDER_COLOR}│${TEXT_COLOR} Pomodoros completed: [$CURRENT/$NUM_POM] ${TAG_COLOR}$TAG$(printf '%-*s' "$TAG_PADDING" '') ${BORDER_COLOR}│${RESET}"
            echo -e "${BORDER_COLOR}│${TEXT_COLOR} Time left: $MINS:$SECS$(printf '%-31s' '') ${BORDER_COLOR}│${RESET}"
            echo -e "${BORDER_COLOR}│${TEXT_COLOR} $MSG$(printf '%-*s' "$MSG_PADDING" '')${BORDER_COLOR}│${RESET}"
            echo -e "${BORDER_COLOR}└─────────────────────────────────────────────────┘${RESET}"
            echo -e "Press ${BORDER_PAUSE_COLOR}p${RESET} to pause/resume, ${BORDER_COMPLETE_COLOR}q${RESET} to quit this pomodoro"
        elif [ "$MSG" = "Paused" ]; then
            echo -e "${BORDER_PAUSE_COLOR}┌──── Pomodoro - ${TIMER_STATE}─────────────────────────┐${RESET}"
            echo -e "${BORDER_PAUSE_COLOR}│${TEXT_COLOR} Pomodoros completed: [$CURRENT/$NUM_POM] ${TAG_COLOR}$TAG$(printf '%-*s' "$TAG_PADDING" '') ${BORDER_PAUSE_COLOR}│${RESET}"
            echo -e "${BORDER_PAUSE_COLOR}│${TEXT_COLOR} Time left: $MINS:$SECS$(printf '%-31s' '') ${BORDER_PAUSE_COLOR}│${RESET}"
            echo -e "${BORDER_PAUSE_COLOR}│${TEXT_COLOR} $MSG$(printf '%-*s' "$MSG_PADDING" '')${BORDER_PAUSE_COLOR}│${RESET}"
            echo -e "${BORDER_PAUSE_COLOR}└─────────────────────────────────────────────────┘${RESET}"
            echo -e "Press ${BORDER_PAUSE_COLOR}p${RESET} to pause/resume, ${BORDER_COMPLETE_COLOR}q${RESET} to quit this pomodoro"
        fi

        if [ $PAUSED -eq 1 ]; then
            # Wait for key press
            read -n 1 -s KEY
            if [ "$KEY" = "p" ]; then
                PAUSED=0
            elif [ "$KEY" = "q" ]; then
                if [ "$NO_SAVE" = false ]; then
                    save_session
                fi
                exit
            fi
        else
            # Read with timeout
            read -t 1 -n 1 -s KEY

            if [ $? -eq 0 ]; then # Checks if any key has been pressed
                if [ "$KEY" = "p" ]; then
                    PAUSED=1
                elif [ "$KEY" = "q" ]; then
                    if [ "$NO_SAVE" = false ]; then
                        save_session
                    fi
                    exit
                fi
            else
                # Decrement if no key
                TIME_LEFT=$((TIME_LEFT - 1))
            fi
        fi
    done

    if [ $TIME_LEFT -le 0 ]; then
        COMPLETED=1
    fi

    STATUS[$CURRENT]=$COMPLETED

    if [ $COMPLETED -eq 1 ]; then
        # Display completed
        notify-send -a "Pomodoro completed!" \
            -r 9897 \
            -u normal \
            -t 2001 \
            -h int:value:"Pomodoro [$CURRENT/$NUM_POM] completed! Take a short break."

        if [ "$SOUND_FILE" != "" ]; then
            # Make vlc run in the background and prevent a nohup.out file being created
            nohup cvlc --play-and-exit --no-video "$SOUND_FILE" > /dev/null 2>&1 &
        fi

        while [ $TIME_LEFT_PAUSE -gt 0 ] || [ $PAUSED -eq 1 ]; do

            PAUSE_MINS=$(printf "%02d" $((TIME_LEFT_PAUSE / 60)))
            PAUSE_SECS=$(printf "%02d" $((TIME_LEFT_PAUSE % 60)))

            printf "\e[2J\e[H"
            # BORDER_COLOR=$RED
            echo -e "${BORDER_COMPLETE_COLOR}┌──── Pomodoro - COMPLETE ────────────────────────┐${RESET}"
            echo -e "${BORDER_COMPLETE_COLOR}│${TEXT_COLOR} Pomodoros completed: [$((CURRENT + 1))/$NUM_POM] ${TAG_COLOR}$TAG$(printf '%-*s' "$TAG_PADDING" '') ${BORDER_COMPLETE_COLOR}│${RESET}"
            echo -e "${BORDER_COMPLETE_COLOR}│${TEXT_COLOR} Time left: 00:00$(printf '%-32s' '')${BORDER_COMPLETE_COLOR}│${RESET}"
            echo -e "${BORDER_COMPLETE_COLOR}│${TEXT_COLOR} Completed!$(printf '%-38s' '')${BORDER_COMPLETE_COLOR}│${RESET}"
            echo -e "${BORDER_COMPLETE_COLOR}└─────────────────────────────────────────────────┘${RESET}"
            echo -e "Break time left: ${BORDER_COLOR}${PAUSE_MINS}:${PAUSE_SECS}${RESET}"
            echo -e "Press ${BORDER_COMPLETE_COLOR}q${RESET} to quit the session, ${BORDER_COLOR}any other key${RESET} to continue"
            read -t 1 -n 1 -s KEY
            if [ $? -eq 0 ]; then # Checks if any key has been pressed
                if [ "$KEY" = "q" ]; then
                    if [ "$NO_SAVE" = false ]; then
                        save_session
                    fi
                    exit
                else
                    COMPLETED=0
                    TIME_LEFT_PAUSE=0
                    continue
                fi
            fi
            TIME_LEFT_PAUSE=$((TIME_LEFT_PAUSE - 1))

            if [ $TIME_LEFT_PAUSE -le 0 ]; then
                COMPLETED=0
            fi
        done
    fi
done

# Save at end
save_session
